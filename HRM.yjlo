import HRMParser from "human-resource-machine-yjlo"
import HeapList
import ListUtil
import HashMap
import Util

class HRM {
	class _Command {
		var type
		var value
		@(t) {
			type = t
		}
		
		func toString() {
			return type + (value?(" "+value):"")
		}
	}
	
	var commands // HeapList
	var cl = [] // command list
	var map = HashMap() // label map
	var floor // array
	var pc = 1 // program counter
	
	size := 0
	speed := 0
	
	var current = null
	
	/* ========== Command functions ========== */
	func addCommand(command_name, value) {
		var cmd = _Command(command_name)
		if value != null {
			cmd.value = value
		}
		cl = $pair(cmd, cl)
		pc++
	}
	
	func label(name) {
		var cmd = _Command("label")
		cmd.value = name
		cl = $pair(cmd, cl)
		map.put(name, pc)
		pc++
	}
	
	/* ------- End of Command functions ------- */
	
	func parse(source, allowed) {
		P := HRMParser(source)
		lines := P.parse()

		while !$is_empty(lines) {
			var line = $head(lines)
			var cmd = line.pull().val()

			if !line.isEmpty() && line.peek().val() == ":" {
				label(cmd)
				lines = $tail(lines)
				continue
			}

			if ListUtil.index(allowed, cmd) == -1 {
				throw("Invalid command: " + cmd)
			}
			switch cmd {
				case "inbox", "outbox" :
					addCommand(cmd)
				case "jump", "jumpz", "jumpn" :
					addCommand(cmd, line.peek().val())
				case "copyfrom", "copyto", "add", "sub", "bumpup", "bumpdn" :
					addCommand(cmd, Util.atoi(line.peek().val()))
				default :
					throw("Invalid command: " + cmd)
			}
			size++
			lines = $tail(lines)
		}
	}
	
	func initFloor(list) {
		floor = list
	}
	
	func run(in_list, out_fun) {
		var i = 0 // program counter
		cl = ListUtil.reverse(cl)
		commands = HeapList(cl)
		
		func labelCheck(label_i, i, current_cmd_value) {
			if label_i == null {
				throw("[" + (i+1) + "] Invalid jump label: "
					+ current_cmd_value)
			}
		}
		
		while i < commands.size() {
			var current_cmd = commands.get(i)
			switch current_cmd.type {
				case "inbox" :
					if $is_empty(in_list) {
						// all inputs are processed
						return
					}
					current = $head(in_list)
					in_list = $tail(in_list)
				case "outbox" :
					out_fun(current)
				case "jump" :
					label_i := map.get(current_cmd.value)
					labelCheck(label_i, i, current_cmd.value)
					i = label_i - 1
				case "jumpz" :
					if current == 0 {
						label_i := map.get(current_cmd.value)
						labelCheck(label_i, i, current_cmd.value)
						i = label_i - 1
					}
				case "jumpn" :
					if current < 0 {
						label_i := map.get(current_cmd.value)
						labelCheck(label_i, i, current_cmd.value)
						i = label_i - 1
					}
				case "copyfrom" :
					current = floor.get(current_cmd.value)
				case "copyto" :
					if current_cmd.value >= floor.size() {
						throw("["+(i+1)+"] Invalid floor number: "
							+ current_cmd.value)
					}
					floor.put(current_cmd.value, current)
				case "add" :
					current += floor.get(current_cmd.value)
				case "sub" :
					current -= floor.get(current_cmd.value)
				case "bumpup" :
					new_value := floor.get(current_cmd.value) + 1;
					floor.put(current_cmd.value, new_value)
					current = new_value
				case "bumpdn" :
					new_value := floor.get(current_cmd.value) - 1;
					floor.put(current_cmd.value, new_value)
					current = new_value
			}
			if current_cmd.type != "label" {
				speed++
			}
			i++
		}
	}
}
